to use mongo shell in docker: docker exec -it mongodb-database /bin/sh 
-- mongodb-database is the container name

- either don't have any environment variables in docker compose file if we don't want to make it secure
- else use command: mongo admin -u uname -p 'password' 
- or use command: mongo admin -u uname -p 'password' --authenticationDatabase admin
- where uname and password should match what is given in docker compose file
- same can be checked using 'env' command since they're environment variables

mongodb is no sql database 
- non relational  database
- document based

type of nosql database:
    - document based
    - key-value based
    - wide-column database
    - graph database

- type 'mongo' in unix shell to open mongo shell and exit() to exit mongo shell
- 'show dbs' command in mongo shell to see list of databases and space they have occupied
    -- if we create any new database it will not show in list of databases (by showdbs) 
        until it has atleast 1 document
- use siddhantdb -- to create a new database and start using it
- db -- to check which database is being currently used
- db.createCollection('FacebookComments') -- to create a new collection in currentl database
- db.instagramComments.insert({username:'siddhant_jain5', post_id:'instagram.com/ab4df', comment:'good'})
    -- 2nd way of creating table <- we directly insert a record in the table and if table is not present,
        it will create the table and insert the record
-- always prefer first way (createCollection command), we can provide additional paramerters in that
- db.createCollection(collection_name, {capped:true, size:5242880, max:5})
    -- capped true means that this collection can have maximum of 5 documents or less
    -- and maximum size cannot exceed 5242880 
    -- if it reaches in 4 documents then only 4 documents will be there
    -- if it reaches in 6 documents then 5 documents will be there

mongodb has two type of documents
- relational documents
- embedded documents (preferred)(better for scalability)

- db.student.insert({regNo: "1234",name: "student1", course: {courseName: "MCA", duration: "3 years"},address: { city: "bangalore", state: "KA", country: "India"}})
-- here couse and address are embedded documents
-- both of them do not have any primary key of their own and are dependent on student object

- mongodb create a unique objectId for each document which is nothing but a primary key (key="_id)
- we can override and mention our own primary key by providing value to _id key
- db.student.insert({_id: "5678", regNo: "5678",name: "student2", course: {courseName: "MCA", duration: "3 years"},address: { city: "bangalore", state: "KA", country: "India"}})
- _id is the only key which is used as primary key, we can't provide any other 

-- to do bulk insert write following in mongo shell
var bulkDocuments = [{username:'siddhant_jain5', post_id:'instagram.com/ab4df', comment:'good'}, {username:'insta_user', post_id:'instagram.com/avg75v', comment:'better'}, {username:'fb_user', post_id:'instagram.com/kjnrke', comment:'best'}]
db.FacebookComments.insert(bulkDocuments)
var bulkDocuments2 = [{username:'siddhant_jain6', post_id:'instagram.com/ab4df', comment:'good'}, {username:'quora_user', post_id:'instagram.com/avg75v', comment:'better'}, {username:'linkedin_user', post_id:'instagram.com/kjnrke', comment:'best'}]
db.FacebookComments.insert(bulkDocuments2)

-- update records in mongodb
- db.FacebookComments.update({comment:"good"},{$set:{"comment":"more than good"}})
-- when we use update, it only changes 1 record even if multiple documents satisfy the condition
-- it starts from top, updates the first document with matching condition and the stops

- db.FacebookComments.update({comment:"better"},{$set:{"comment":"all better"}}, {multi:true})
-- {multi:true} will change all records matching the condition

-- upsert in mongodb
- db.FacebookComments.update({comment:"better"},{$set:{"comment":"all better"}}, {upsert:true})
-- if it finds a record with comment "better" it updates that record
-- else it create a new record with just one key:value i.e. what we mentioned in set command

-- delete document in mongodb
- db.FacebookComments.remove({"comment":"all better"})
-- remove command will remove all records (unlike update command)

- show collections -- to get list of collections in current database
- db.instagramComments.find() -- to list all records in a collection
- db.instagramComments.find().pretty() -- to format documents properly like a json

-- to query documents based on some condition
- db.FacebookComments.find({comment:"best"})
-- it will return all the records which match the condition
-- if we give any key which is not in documents then it will give empty result and not error
    bcz it is nosql so no fixed schema, key can be present in one doc and not present in another

db.FacebookComments.find().limit(2)
-- to limit number of records displayed (first 2 records will be shown)

--sort the records
db.FacebookComments.find().sort({username: -1})
-- -1 will sort it in descending order
-- 1 will sort in ascending order

-- search based on embedded column
db.student.find({"address.city": "bangalore"})

-- find all students with student ids between a range
- db.student.insert({regNo: "1240",name: "student3", course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student.insert({regNo: "1284",name: "student4", course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student.insert({regNo: "1354",name: "student5", course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student.insert({regNo: "5234",name: "student6", course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})

- db.student.find({regNo: {$gt: "5000"}}) -- get all record will regNo greater than(gt) 5000 
    -- since input is a string if we provide 5000 without quotes in query, it will not return anything
- db.student.find({regNo: {$lt: "5000"}})
- db.student.find({regNo: {$in: ["1240","1340"]}}) -- only records which have regNo as either 1240 or 1340
- db.student.find({regNo: {$gt: "1240", $lt:"1354"}}) -- boundaries exclusive (1240 and 1354 will not be in o/p)

-- indexing in mongodb
- db.student_new.insert({regNo: "1234",name: "student1", section:"F4", course: {courseName: "MCA", duration: "3 years"},address: { city: "bangalore", state: "KA", country: "India"}})
- db.student_new.insert({regNo: "5678",name: "student2", section:"F2", course: {courseName: "MCA", duration: "3 years"},address: { city: "bangalore", state: "KA", country: "India"}})
- db.student_new.insert({regNo: "1240",name: "student3", section:"F4", course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student_new.insert({regNo: "1284",name: "student4", section:"F2", course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student_new.insert({regNo: "1354",name: "student5", section:"F4", course: {courseName: "MCA", duration: "3 years"},address: { city: "jaipur", state: "UP", country: "India"}})
- db.student_new.insert({regNo: "5234",name: "student6", section:"F2", course: {courseName: "MCA", duration: "3 years"},address: { city: "jaipur", state: "UP", country: "India"}})
- db.student_new.explain("executionStats").find({section: "F4"})
-- under executionStats there is a key called totalDocsExamined: its value is 6 
    -- which is total number of records in the collection right now
-- if there are millions of records, then it will go through all million records to search for given criteria

- db.student_new.createIndex({section: 1})
 -- to apply index on section key,and 1 to have it in ascending order
 -- this will add another index, and not remove current indexes
 -- since before it was 1, if we run getIndexes now it will give 2
 -- now executionStats command will show totalDocsExamined value as 3 
    -- which is no. of rec having this value

- db.student_new.dropIndex("section_1")
 -- if we check in getIndexes this will be mentioned as name
 -- first is the key name followed by underscore followed by ascending or descending
 -- if we just say key name it will throw error saying index not found

-- aggregations in mongodb
$project -> to select specific fields
$match -> filter operation
$group -> aggregation operation
$sort -> sort operation
- db.student_new.aggregate([{"$match": {$and: [{"section":"F4"}, {"regNo":{"$gt":"1239"}}]} }])
- db.student_new.aggregate([{"$project":{"name":1, "section":1, "address.city":1}}])
    -- if we mention 1 it will be displayed and if we mention 0 then not displayed
    -- we can also skip the columns we don't want to select
    -- for _id column we explicitly need to mention 0 otherwise it will be displayed

- db.student_new.aggregate([{"$project":{"name":1, "section":1, "address.city":1, "_id":0}}])
- db.student_new.aggregate([{"$match": {"section":"F4"}}, {"$project":{"name":1, "section":1, "address.city":1, "_id":0}}])

-- group by aggregations
- db.student_marks.insert({regNo: 1234,name: "student1", section:"F4", marks:80.5, course: {courseName: "MCA", duration: "3 years"},address: { city: "BLORE", state: "KA", country: "India"}})
- db.student_marks.insert({regNo: 5678,name: "student2", section:"F2", marks:70.5, course: {courseName: "MCA", duration: "3 years"},address: { city: "BLORE", state: "KA", country: "India"}})
- db.student_marks.insert({regNo: 1240,name: "student3", section:"F4", marks:65, course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student_marks.insert({regNo: 1284,name: "student4", section:"F2", marks:92.5, course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student_marks.insert({regNo: 1354,name: "student5", section:"F4", marks:41.2, course: {courseName: "MCA", duration: "3 years"},address: { city: "jaipur", state: "RAJ", country: "India"}})
- db.student_marks.insert({regNo: 5234,name: "student6", section:"F2", marks:33, course: {courseName: "MCA", duration: "3 years"},address: { city: "jaipur", state: "RAJ", country: "India"}})
- db.student_marks.insert({regNo: 1235,name: "student7", section:"F4", marks:35, course: {courseName: "MCA", duration: "3 years"},address: { city: "BLORE", state: "KA", country: "India"}})
- db.student_marks.insert({regNo: 5676,name: "student8", section:"F2", marks:95, course: {courseName: "MCA", duration: "3 years"},address: { city: "BLORE", state: "KA", country: "India"}})
- db.student_marks.insert({regNo: 1236,name: "student9", section:"F4", marks:48, course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student_marks.insert({regNo: 1237,name: "student10", section:"F2", marks:12, course: {courseName: "MCA", duration: "3 years"},address: { city: "jhansi", state: "UP", country: "India"}})
- db.student_marks.insert({regNo: 1338,name: "student11", section:"F4", marks:48, course: {courseName: "MCA", duration: "3 years"},address: { city: "jaipur", state: "RAJ", country: "India"}})
- db.student_marks.insert({regNo: 5239,name: "student12", section:"F2", marks:100, course: {courseName: "MCA", duration: "3 years"},address: { city: "jaipur", state: "RAJ", country: "India"}})

- db.student_marks.aggregate([{"$group":{"_id": {"section": "$section"}, "TotalMarks":{"$sum": "$marks"}}}])
    -- id is compulsory in group by
- db.student_marks.aggregate([{"$group":{"_id": {"section": "$section"}, "TotalMarks":{"$sum": "$marks"}, "Count":{$sum:1}, "AverageMarks":{$avg: "$marks"}}}])
- db.student_marks.aggregate([{$match:{section: 'F4'}},{"$group":{"_id": {"section": "$section"}, "TotalMarks":{"$sum": "$marks"}}}])

- db.student_new.getIndexes() --> go get which key is current index, by default '_id'
- db.student.count() --find number of documents in a collection

- all mongodb database are stored in /data/db folder
- table in sql is collection in mongodb
- row in sql is document in mongodb (single record)

-- replication in mongodb
-- replication and high availability are main features of mongodb
-- they come inbuilt with mongodb and no separate s/w installation is required
-- replication done with master(one)-slave(many) architecture
-- can me done using mongodb atlas
-- in atlas we can create one free cluster (which is by default 3 node cluster)
-- one primary node and two secondary
-- we can insert record only in primary node and read from secondary also
-- we need to provide network access and database access in atlas

--------------------------------------------------------------------
-- mongo db stores bson (which are binary json)
-- max document size in mongodb can be 16mb
-- mongodb doesn't enforce any foreign key relationship
    -- there can be soft foreign keu relation ship
    -- like book collection can have publisherid key
    -- and there can be a separate publisher collection where we can get all info 
        -- of a publisher using the publisherid
    -- but no rules like publisherkey should be mandtorily be present in
        -- publisher collection are enforced by mongodb (we need to take care of that)
-- any table which is a dependent of another table can be an embedded document
    -- for eg. rating is dependent on books or address is dependent on customers
    -- these documents(rating/address) have no meaning by themselves
    -- these do not need to be separate collection in mongodb
    -- they can be a document or array of documents inside the collection they're dependent on
    -- this saves us from performing several joins to get this data
    -- drawback is it's a bit of overhead if we mostly don;t require ratings info with books
-- when to use embedded documents
    -- check if embedded doc is wanted 80% time or not?
        -- for eg. if we are displaying books on e-commerce website where we displayed
            ratings everytime, then we should keep it as an embedded document
        -- suppose on a page the user only sees the list books that he has purchased
            and doesn't require ratings since it is already purchased. then no a good
            idea to go with embedded documents.
    -- is embedded data a bounded set?
        -- for eg rating will keep growing for a book as the site and the book 
            gain popularity. so as more people rate the document will keep getting bigger 
            and bigger and hence will not be a good idea to embed it
            it might surpass 16mb size at some point which is not possible in mongodb
        -- but if that embedded doc size if limited than fine, like a customer might have 
            max of 2-3 addresses
    -- how varied are your queries?
        -- for eg. if a query is normal like get all list of books with its ratings, then 
            embedded documents is a good idea
        -- but if they're different type of queries, then data modelling should differ
    -- whether it's integration db or application db
        -- application db is which we use for a small scale application. where each application
            has a single db associated to it.
        -- integration db are used by large enterprise, where lot of different application
            use the same db
        -- all application should agree with the defined data model
        -- easier to design data for application db

- video course on mongodb and ODM (object document mapper) similar to ORM
    https://www.youtube.com/watch?v=E-1xI85Zog8
- Udemy course of the exact same vide (broken into lesson)(enrolled in udemy account)
    https://www.udemy.com/course/draft/1358396/learn/lecture/8222114?start=0#overview
- github repo of the above video:
    https://github.com/mikeckennedy/mongodb-quickstart-course/tree/master/src/snake_bnb/src

check for $elemmatch $gte $lte 

-----------------------------------------------------------------------------------------

mongod is the database server, it should always be running if we want to connect to it
by default it runs on port 27017, we can change it by adding --port to mongod command
same --port can be used with mongo command to open shell and connect it to server
in windows it runs as a service in background and we don't need to manually run it
but in linux and mac we need start it manually and keep it running as long as we want to access it
the command for it is: mongod
it looks for /db/data path in root folder or c/users_username (windows), 
    if path is not present it fails to start
if we want to store db in a different path then command is: mongod --dbpath "path of /db/data"

https://www.youtube.com/playlist?list=PLp50dWW_m40UWFSV6PTgYzciZJIxgHy7Q
https://medium.com/p/8f8e6f77cad9/edit